<% 
res <- Response$new()
config <- list(inputFile=list(fileName=NA,
                 hasHeader=NA,
                 sep=NA,
                 decSep=NA,
                 skip=NA), 
               config=list(
                 ncores=1,
                 inEpsg=-1,
                 outEpsg=-1,
                 inUnit="ido",
                 outUnit="ius",
                 internetConnection=ifelse(class(try(getURL("www.google.com"))) == "try-error", FALSE, TRUE),
                 expVectDriver=c("ESRI Shapefile", "KML"),
                 expVectExt=c("shp", "kml"),
                 expRastDriver=c("GTiff"),
                 expRastExt=c("tif"),
                 expData=0,
                 useGM=0,
                 skip=0,
                 sep="comma",
                 sepDec=",",
                 duplicates="jitter", 
                 dateTime=NA,
                 verbose=1,
                 writeLog=1,
                 longNames=list(animals=list(
                                  short=c("initNRows",
                                    "duplicatesN",
                                    "duplicatesWhatTodo",
                                    "nMissingCases",
                                    "finalNRows"),
                                  long=c("Number of relocations",
                                    "Number of duplicates",
                                    "Dealing with duplicates",
                                    "Number incomplete",
                                    "Final Number of relocations")),
                   siteFidelity=list(
                     short=c("n"),
                     long=c("No of simulated trajectories")),
                   ttsi=list(
                     short=c("interval", "consec", "alpha", "ntimes"),
                     long=c("Interval [sec]", "Consecutive obervations", "Alpha", "Number of times above")),
                   mcp=list(
                     short=c("level"),
                     long=c("Isopleth level")),
                   kde=list(
                     short=c("resolution",
                       "buffer",
                       "level",
                       "bandwidth",
                       "bandwidthValue",
                       "smoothing",
                       "kernel",
                       "contouring",
                       "rescale",
                       "lscvWhichMin",
                       "lscvFailure",
                       "hx",
                       "hy"),
                     long=c("Resolution [map units]",
                       "Buffer [map units]",
                       "Level",
                       "Bandwidth method",
                       "Bandwidth value",
                       "Smoothing method",
                       "Kernel",
                       "Contouring method",
                       "Rescaling method",
                       "LSCV minimum",
                       "LSCV failure",
                       "bandwidth value (x-direction)",
                       "bandwidth value (y-direction)")),
                   locoh=list(
                     short=c("type", "n", "nValue", "level"),
                     long=c("Type", "Determine n automatically", "Value of n", "Isopleth level")),
                   asymptote=list(
                     short=c("nIter",
                       "minNPts",
                       "increment",
                       "estimator",
                       "level",
                       "nTimes",
                       "tolTotArea",
                       "sampling"),
                     long=c("Number of iterations",
                       "Minimum number of points",
                       "Incrementing by",
                       "Estimator",
                       "Isopleth level",
                       "Number of consecutive times",
                       "Tolerance to total area",
                       "Sampling")),
                   ca=list(
                     short=c("res"),
                     long=c("Resolution")))
                 ),
               mapFields=list(
                 id=NA, 
                 lat=NA, 
                 lon=NA, 
                 date=list(date=NA, dateFormat=NA), 
                 time=list(time=NA, timeFormat=NA)), 
               animal=list(ids=NA, include=NA),
               spBbx=list(xmin=NA, xmax=NA, ymin=NA, ymax=NA), 
               spBbxRestricted=list(xmin=NA, xmax=NA, ymin=NA, ymax=NA), 
               temporalBbx=list(tmin=NA, tmax=NA), 
               temporalBbxRestricted=list(tmin=NA, tmax=NA), 
               n=list(initialN=NA, restrictedN=NA), 
               analysis=list(siteFidelity=list(n=100),
                 ttsi=list(interval=5 * 60 * 60, consec=c(TRUE), alpha=0.25, ntimes=3), 
                 mcp=list(level=95), 
                 kde=list(resolution=100, buffer=1000, level=95, bandwidth="href", bandwidthValue=-1, smoothing="fixed", kernel="normal", contouring="volume", rescale="none", lscvWhichMin=-1, lscvFailure=-1), 
                 locoh=list(type="k", n=FALSE, nValue=40, level=95), 
                 ca=list(res=100),
                 asymptote=list(nIter=10, minNPts=50, increment=50, estimator=c("mcp"), level=95, nTimes=5, tolTotArea=5, sampling="sequential")),
               todo=list(doSiteFidelity=FALSE, doTTSI=FALSE, doAsymptote=FALSE, doMCP=FALSE, doKDE=FALSE, doLocoh=FALSE, doCA=FALSE),
               background=list(siteFidelity="Site fidelity is the concept that animals have preference for one site and not move randomly through space. Two measures were used to asses site fidelity: MSD (mean squared distance from the centroid) and LI (linearity index). Linearity is defined as the distance between the first and last relocation diveded by the total distance travelled. A LI of 1 suggest linear movement and LI < 1 suggests that animal meander.", ttsi="Time to statistical independence calculates at which time intervall Schoeners V reaches the expected value of 2. The x-axis on the plots shows the time intervall in seconds and on the y axis m indicates the number of pairs (i.e., the number segments of the trajectory) and Schoeners V is calcualted as.", mcp="Minimum convex polygon (MCP) is one of the older methods to calculate home ranges. It been shown that MCP estimates for home ranges are biased and often overestimated. The points used within a MCP are determined by calculating the centroid of all points and then desired percentage of closest points are selected. With the selected points a MCP is calculated.", kde="Kernel density estimation (KDE) is one of the most widely used methods to calculate home ranges. In the first step a kernel density estimation is calculated. From the kernel density a utility distribution (UD) is calculated.", locoh="Local Convex Hull is a hull based method, where minimum convex polygons are calculated for each point with a given set of neighbors. There are different methods available to determine which neighbors to be used.", ca="Core area is commonly estimated by a certain percentage home range level."))
               res$write(cat(toJSON(config)))
               res$finish()
%>
